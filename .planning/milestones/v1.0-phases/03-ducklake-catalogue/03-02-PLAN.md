---
phase: 03-ducklake-catalogue
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - scripts/apply_comments.R
  - scripts/create_views.sql
autonomous: true

must_haves:
  truths:
    - "Table comments are visible via COMMENT ON TABLE in the DuckLake catalogue"
    - "Column comments are visible via COMMENT ON COLUMN in the DuckLake catalogue"
    - "4 non-spatial source views are recreated in the catalogue"
    - "8 WECA-filtered views exist for tables with LA code columns"
  artefacts:
    - path: "scripts/apply_comments.R"
      provides: "Script that extracts comments from source DuckDB and applies them to DuckLake"
      contains: "COMMENT ON"
    - path: "scripts/create_views.sql"
      provides: "SQL script creating all non-spatial views and WECA-filtered views"
      contains: "CREATE VIEW"
  key_links:
    - from: "scripts/apply_comments.R"
      to: "data/mca_env_base.duckdb"
      via: "Reads table/column comments from source"
      pattern: "duckdb_columns|duckdb_tables"
    - from: "scripts/create_views.sql"
      to: "s3://stevecrawshaw-bucket/ducklake/mca_env.ducklake"
      via: "Creates views in attached DuckLake catalogue"
      pattern: "CREATE VIEW lake"
---

<objective>
Apply table and column comments from the source DuckDB to the DuckLake catalogue, and create all non-spatial views plus WECA-filtered views.

Purpose: Comments make the catalogue self-documenting for analysts. Views provide pre-built queries for common access patterns (WECA-area filtering, combined authority lookups).
Output: A fully commented catalogue with 4 source views and 8 WECA-filtered views.
</objective>

<execution_context>
@C:\Users\steve.crawshaw\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\steve.crawshaw\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ducklake-catalogue/03-RESEARCH.md
@.planning/phases/03-ducklake-catalogue/03-CONTEXT.md
@.planning/phases/03-ducklake-catalogue/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply table and column comments to DuckLake catalogue</name>
  <files>scripts/apply_comments.R</files>
  <action>
Create `scripts/apply_comments.R` that:

1. Opens an in-memory DuckDB connection
2. Installs and loads `ducklake`, `httpfs`, `aws` extensions
3. Creates S3 secret with credential_chain (TYPE s3, REGION 'eu-west-2', PROVIDER credential_chain)
4. Attaches the DuckLake catalogue: `ATTACH 'ducklake:s3://stevecrawshaw-bucket/ducklake/mca_env.ducklake' AS lake (DATA_PATH 's3://stevecrawshaw-bucket/ducklake/data/')`
5. Attaches the source database: `ATTACH 'data/mca_env_base.duckdb' AS source (READ_ONLY)`
6. Extracts table comments from source:
   ```sql
   SELECT table_name, comment FROM source.duckdb_tables()
   WHERE schema_name = 'main' AND NOT internal AND comment IS NOT NULL
   ```
7. Extracts column comments from source:
   ```sql
   SELECT table_name, column_name, comment FROM source.duckdb_columns()
   WHERE schema_name = 'main' AND comment IS NOT NULL AND comment != ''
   ```
8. Generates and executes COMMENT ON TABLE statements for each table comment:
   `COMMENT ON TABLE lake.{table_name} IS '{escaped_comment}'`
   - Escape single quotes by doubling them
   - Leave comments empty where source has no description (do NOT add placeholders)
   - Copy descriptions verbatim -- no enrichment
9. Generates and executes COMMENT ON COLUMN statements for each column comment:
   `COMMENT ON COLUMN lake.{table_name}.{column_name} IS '{escaped_comment}'`
   - Description only -- no data type info
10. Prints summary: number of table comments applied, number of column comments applied
11. Verifies by querying a sample: `SELECT comment FROM duckdb_tables() WHERE database_name = 'lake' AND table_name = 'la_ghg_emissions_tbl'`

The source has 18 tables with comments and ~663 columns with comments (out of 809 total). Use tryCatch around each COMMENT ON statement so failures on individual columns do not halt the script. Log any failures.
  </action>
  <verify>
Run `scripts/apply_comments.R` from the project root. It should:
1. Report ~18 table comments applied
2. Report ~663 column comments applied (some may fail if columns differ between source and DuckLake)
3. Print the sample comment for la_ghg_emissions_tbl

Then verify from DuckDB CLI:
```sql
INSTALL ducklake; LOAD ducklake;
CREATE SECRET (TYPE s3, REGION 'eu-west-2', PROVIDER credential_chain);
ATTACH 'ducklake:s3://stevecrawshaw-bucket/ducklake/mca_env.ducklake' AS lake (READ_ONLY);
SELECT table_name, comment FROM duckdb_tables() WHERE database_name = 'lake' AND comment IS NOT NULL LIMIT 5;
SELECT table_name, column_name, comment FROM duckdb_columns() WHERE database_name = 'lake' AND comment IS NOT NULL LIMIT 10;
```
  </verify>
  <done>
Table comments visible for all 18 tables in DuckLake. Column comments visible for ~663 columns. Descriptions copied verbatim from source with no enrichment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create non-spatial source views and WECA-filtered views</name>
  <files>scripts/create_views.sql, scripts/apply_comments.R</files>
  <action>
Create `scripts/create_views.sql` containing all view definitions, then add execution of this SQL to the end of `scripts/apply_comments.R` (or create a separate R script; simpler to append since the DuckLake connection is already open).

**4 non-spatial source views** (copy SQL from source database, replacing bare table references with `lake.` prefix):

1. `ca_la_lookup_inc_ns_vw`:
```sql
CREATE VIEW lake.ca_la_lookup_inc_ns_vw AS
(SELECT LAD25CD AS ladcd, LAD25NM AS ladnm, CAUTH25CD AS cauthcd, CAUTH25NM AS cauthnm
 FROM lake.ca_la_lookup_tbl)
UNION BY NAME
(SELECT 'E06000024' AS ladcd, 'North Somerset' AS ladnm,
        'E47000009' AS cauthcd, 'West of England' AS cauthnm);
```

2. `weca_lep_la_vw`:
```sql
CREATE VIEW lake.weca_lep_la_vw AS
SELECT * FROM lake.ca_la_lookup_inc_ns_vw WHERE cauthnm = 'West of England';
```

3. `ca_la_ghg_emissions_sub_sector_ods_vw`:
```sql
CREATE VIEW lake.ca_la_ghg_emissions_sub_sector_ods_vw AS
WITH joined_data AS (
    SELECT * FROM lake.la_ghg_emissions_tbl AS ghg
    INNER JOIN lake.ca_la_lookup_inc_ns_vw AS ca ON ghg.local_authority_code = ca.ladcd
)
SELECT * EXCLUDE (country, country_code, ladcd, ladnm, region, second_tier_authority)
FROM joined_data;
```

4. `epc_domestic_vw`:
```sql
CREATE VIEW lake.epc_domestic_vw AS
SELECT c.*,
    CASE
        WHEN regexp_matches(CONSTRUCTION_AGE_BAND, '(\d{4})-(\d{4})') THEN
            CAST(round((CAST(regexp_extract(CONSTRUCTION_AGE_BAND, '(\d{4})-(\d{4})', 1) AS INTEGER) +
                        CAST(regexp_extract(CONSTRUCTION_AGE_BAND, '(\d{4})-(\d{4})', 2) AS INTEGER)) / 2.0) AS INTEGER)
        WHEN regexp_matches(CONSTRUCTION_AGE_BAND, 'before (\d{4})') THEN
            CAST(regexp_extract(CONSTRUCTION_AGE_BAND, 'before (\d{4})', 1) AS INTEGER) - 1
        WHEN regexp_matches(CONSTRUCTION_AGE_BAND, '(\d{4}) onwards') THEN
            CAST(regexp_extract(CONSTRUCTION_AGE_BAND, '(\d{4}) onwards', 1) AS INTEGER)
        WHEN regexp_matches(CONSTRUCTION_AGE_BAND, '(\d{4})') THEN
            CAST(regexp_extract(CONSTRUCTION_AGE_BAND, '(\d{4})', 1) AS INTEGER)
        ELSE NULL
    END AS NOMINAL_CONSTRUCTION_YEAR,
    CASE
        WHEN NOMINAL_CONSTRUCTION_YEAR < 1900 THEN 'Before 1900'
        WHEN NOMINAL_CONSTRUCTION_YEAR >= 1900 AND NOMINAL_CONSTRUCTION_YEAR <= 1930 THEN '1900 - 1930'
        WHEN NOMINAL_CONSTRUCTION_YEAR > 1930 THEN '1930 to present'
        ELSE 'Unknown'
    END AS CONSTRUCTION_EPOCH,
    CASE
        WHEN lower(TENURE) = 'owner-occupied' THEN 'Owner occupied'
        WHEN lower(TENURE) = 'rented (social)' THEN 'Social rented'
        WHEN lower(TENURE) = 'rental (social)' THEN 'Social rented'
        WHEN lower(TENURE) = 'rental (private)' THEN 'Private rented'
        WHEN lower(TENURE) = 'rented (private)' THEN 'Private rented'
        ELSE NULL
    END AS TENURE_CLEAN,
    year(LODGEMENT_DATETIME) AS LODGEMENT_YEAR,
    month(LODGEMENT_DATETIME) AS LODGEMENT_MONTH,
    day(LODGEMENT_DATETIME) AS LODGEMENT_DAY
FROM lake.raw_domestic_epc_certificates_tbl AS c;
```

**3 spatial-dependent views** -- SKIP entirely (defer to Phase 4):
- ca_boundaries_inc_ns_vw (st_transform, spatial tables)
- epc_domestic_lep_vw (geopoint_from_blob, open_uprn_lep_tbl spatial join)
- epc_non_domestic_lep_vw (geopoint_from_blob, open_uprn_lep_tbl spatial join)

**8 WECA-filtered views** using `_weca_vw` suffix. WECA LA codes: E06000022, E06000023, E06000024, E06000025.

| Table | Filter Column | View Name |
|-------|---------------|-----------|
| la_ghg_emissions_tbl | local_authority_code | la_ghg_emissions_weca_vw |
| la_ghg_emissions_wide_tbl | local_authority_code | la_ghg_emissions_wide_weca_vw |
| raw_domestic_epc_certificates_tbl | LOCAL_AUTHORITY | raw_domestic_epc_weca_vw |
| raw_non_domestic_epc_certificates_tbl | LOCAL_AUTHORITY | raw_non_domestic_epc_weca_vw |
| boundary_lookup_tbl | ladcd | boundary_lookup_weca_vw |
| postcode_centroids_tbl | lad25cd | postcode_centroids_weca_vw |
| iod2025_tbl | la_cd | iod2025_weca_vw |
| ca_la_lookup_tbl | LAD25CD | ca_la_lookup_weca_vw |

Each WECA view follows the pattern:
```sql
CREATE VIEW lake.{view_name} AS
SELECT * FROM lake.{table_name}
WHERE {filter_column} IN ('E06000022', 'E06000023', 'E06000024', 'E06000025');
```

Write all view SQL into `scripts/create_views.sql`. Then either append view creation to `scripts/apply_comments.R` after the comment application section, or create a small additional section that reads and executes `create_views.sql`. Use tryCatch around each CREATE VIEW so individual view failures are logged but do not halt execution.

After creating views, verify with:
```sql
SELECT view_name FROM duckdb_views() WHERE database_name = 'lake' ORDER BY view_name;
SELECT COUNT(*) FROM lake.la_ghg_emissions_weca_vw;
SELECT COUNT(*) FROM lake.weca_lep_la_vw;
```
  </action>
  <verify>
Run the view creation (either as part of apply_comments.R or separately). It should:
1. Create 4 source views without error
2. Create 8 WECA-filtered views without error
3. Print all 12 view names

Verify from DuckDB CLI:
```sql
INSTALL ducklake; LOAD ducklake;
CREATE SECRET (TYPE s3, REGION 'eu-west-2', PROVIDER credential_chain);
ATTACH 'ducklake:s3://stevecrawshaw-bucket/ducklake/mca_env.ducklake' AS lake (READ_ONLY);
SELECT view_name FROM duckdb_views() WHERE database_name = 'lake';
SELECT COUNT(*) FROM lake.weca_lep_la_vw;
SELECT COUNT(*) FROM lake.la_ghg_emissions_weca_vw;
SELECT * FROM lake.epc_domestic_vw LIMIT 1;
```
  </verify>
  <done>
4 non-spatial source views and 8 WECA-filtered views exist in the DuckLake catalogue. weca_lep_la_vw returns 5 rows (4 WECA authorities + North Somerset). WECA-filtered views correctly filter by LA code.
  </done>
</task>

</tasks>

<verification>
1. Table comments visible: `SELECT table_name, comment FROM duckdb_tables() WHERE database_name = 'lake' AND comment IS NOT NULL` returns 18 rows
2. Column comments visible: `SELECT COUNT(*) FROM duckdb_columns() WHERE database_name = 'lake' AND comment IS NOT NULL` returns ~663
3. Source views: ca_la_lookup_inc_ns_vw, weca_lep_la_vw, ca_la_ghg_emissions_sub_sector_ods_vw, epc_domestic_vw all queryable
4. WECA views: All 8 _weca_vw views return data filtered to the 4 WECA LA codes
5. Spatial views NOT created (deferred to Phase 4)
</verification>

<success_criteria>
Table and column comments are visible in the DuckLake catalogue. 12 views (4 source + 8 WECA-filtered) are queryable. No spatial-dependent views attempted.
</success_criteria>

<output>
After completion, create `.planning/phases/03-ducklake-catalogue/03-02-SUMMARY.md`
</output>
